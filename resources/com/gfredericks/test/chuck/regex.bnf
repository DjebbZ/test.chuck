Regex = BCC

BCC = <'['> BCCIntersection <'&&'>? <']'>
(* using + with '&&' allows arbitrary even numbers of ampersands, which
   is how the jvm parses it *)
BCCIntersection = BCCUnionLeft (<BCCEvenAmpersands> BCCUnionNonLeft ) *
BCCUnionLeft = (BCCNegation BCCElemHardLeft | !'^' BCCElemHardLeft) BCCElemNonLeft *
BCCUnionNonLeft = BCCElemLeft BCCElemNonLeft *
BCCNegation = '^'
BCCEvenAmpersands = ('&&' + !'&')
BCCOddAmpersands = '&' <'&&'>* ! '&'

(* The optional '&&' here cover some quirky NOOP edge cases *)
BCCElemHardLeft = !'&&&' <'&&'> ? BCCElemBase | (']' ! ('-' BCCRangeRightable)) | BCCRangeWithBracket
BCCElemLeft = BCCElemBase
BCCElemNonLeft = BCCElemBase


BCCElemBase = BCCCharNonRange | BCCRange | BCC
BCCRangeRightable = BCCCharEndRange | '&'
BCCRange = BCCChar <'-'> BCCCharEndRange
BCCRangeWithBracket = <']-'> BCCCharEndRange
BCCCharNonRange = BCCChar ! ('-' BCCRangeRightable)
BCCChar = BCCPlainChar | EscapedChar | BCCOddAmpersands
BCCCharEndRange = BCCPlainChar | EscapedChar | BCCAmpersandEndRange
BCCAmpersandEndRange = '&' <(!'&' | BCCOddAmpersands)>
BCCPlainChar = #"[^\]\[&\\]"
(* only match an odd number of ampersands whatever *)
(* This is problematic because re-pattern won't take repeated ampersands in the HardLeft position *)
BCCDash = '-'


(** BASE CHARACTER STUFFS **)

EscapedChar = ControlChar

ControlChar = <'\\c'> (<'\\'> #"(?s)." | ! '\\' #"(?s).")
